ParticleData
=============

One of the basic assumptions in UAMMD is that simulations are based on the state of "particles". ParticleData is the class in UAMMD that stores the properties of all the particles in the system.

This class takes care of allocating the necessary memory and providing accesses to any property in either the GPU or CPU.

Most UAMMD modules will need to be provided with a reference to a ParticleData instance.  

ParticleData handles and stores all properties a particle can have (however, they are only initialized when they are asked for the first time). It offers several ways to access these properties. See USAGE.  

ParticleData can change the size of the properties, shuffle the particles indices or change the container of a particular property at any given time. The relevant changes are announced using signals, so code using ParticleData should handle these events as needed, see Connecting to a signal.  

*****

Creation
----------
ParticleData only needs a number of particles at creation. Optionally, a :ref:`System` instance can also be provided as a second argument.

.. code:: c++
	  
  auto pd = make_shared<ParticleData>(numberParticles);

.. _particle_id_assignation:

Particle id assignation
------------------------

When added each particle is assigned an unique id or name (which corresponds to its position in the underlying container just after ParticleData creation). At this moment one can access the position of particle with id=i at pos[i].  
A reordering or some other internal processes may alter this fact, making the index of the particle with id=i not correspond to i anymore.   
While the location of each particle in the internal containers might change, the particles ids (names) will never change.  
The current ids are available through the property "Id" in ParticleData:

.. code:: cpp
	  
  auto index2id = pd->getId(access::cpu, access::read);
  int someIndex=0;
  int nameOfParticleAtSomeIndex = index2id[someIndex];
  
The opposite indirection is also accessible through ParticleData. That is finding the current index of a certain particle through its id (name):

.. code:: cpp
	  
  auto id2index = pd->getIdOrderedIndices(access::cpu);
  int someId=0;
  int indexOfParticleWithSomeId = id2index[someId];

Thrust offers a permutation_iterator that can be used to mask this behavior to access a certain property by either id or index:

.. code:: cpp
	  
  auto positionWithArbitraryOrder = pd->getPos(access::cpu, access::read);
  //Accessing particles when order is not important 
  int someIndex = 0;
  real4 positionOfParticleAtSomeIndex = pos[someIndex];
  auto index2id = pd->getId(access::cpu, access::read);
  int idOfParticleAtSomeIndex = index2id[someIndex];
  //Accessing particles so index = name
  int someId = 0;
  auto id2Index = pd->getIdOrderedIndices(access::cpu);
  //Using a simple indirection
  real4 positionOfParticleWithSomeId = positionWithArbitraryOrder[id2index[someId]];
  //Using a permutation iterator
  auto positionOrderedById = thrust::make_permutation_iterator(positionWithArbitraryOrder, id2index);
  real4 positionOfParticleWithSomeId = positionOrderedById[someId];

Getting a handle get a certain property
------------------------------------------

You can access a property from GPU or CPU memory and must specify the kind of access (read, write, readwrite).  

.. code:: cpp
	  
  auto radius = pd->getRadius(access::gpu, access::write);
  thrust::fill(thrust::cuda::par, radius.begin(), radius.end(), 1.0); 
  auto force = pd->getForce(access::cpu, access::write);
  std::fill(force.begin(), force.end(), real4());
  auto id = pd->getId(access::cpu, access::read); //It is not legal to write to ID, one can only read from it.
  int* raw_id_property_pointer = id.raw();

If the mode is set to write, the handle will gain exclusivity and no one else will be able to access it until it is released (the handle is deleted).   
UAMMD cannot write to a property that is currently being read and cannot read from a property that is currently being written to.   
For this **it is important to control the scope of the property handles**.  
Handles are compatible with std and thrust algorithms and can be considered c++ iterators for all porpoises.  

.. _list-of-available-properties:

List of available properties
-----------------------------

The beginning of ParticleData.cuh contains a list of available per particle properties (such as positons, velocities, forces...).  
You can see a list of all the available ones and add more properties by appending to the macro ALL_PROPERTIES_LIST.  
A family of access functions will be autogenerated for each property inside this macro (such as get[Name] (), [Name]WrittenSignal(), ...).   

For instance, ParticleData holds the positions of the particles in :cpp:type:`real4` variables in an array named "pos". Thus, the function :cpp:`property_ptr<real4> ParticleData::getPos()` is available.

Basic properties include (type name):
  * :cpp:`real4 pos`
  * :cpp:`real3 vel`
  * :cpp:`real4 force`
  * :cpp:`real energy`
  * :cpp:`real virial`
  * :cpp:`real mass`
  * :cpp:`real charge`
  * And more defined in ParticleData.cuh
 
Advanced usage
---------------

ParticleData allocates properties the first time they are requested. Sometimes one would like to know if a certain property has been previously requested to decide upon a fall back behavior.
For example, one would like to use the mass of each particle for a certain algorithm. If mass has not been set for each particle independently one would like to assume that all particles have the same mass, equal to some default value. There are two ways to obtain this information:

.. code:: cpp
	  
  bool isMassAllocated = pd->isMassAllocated();
  auto mass = pd->getMassIfAllocated(access::gpu, access::read);
  //mass.raw() will be nullptr if mass has not been asked for before (either in GPU or CPU). 
  //Note that this call will never allocate the property

Triggering a sorting
*********************

ParticleData can sort the particles to increase spatial locality of the data, which might be beneficial for some algorithms.
To force a sorting:

.. code:: cpp
	  
  pd->sortParticles();


Signals
*********

ParticleData broadcasts a signal every time some internal processes undergo, such as a particle reordering or a resize.  
One can subscribe to these signals like this:

.. code:: cpp
	  
  class User{
    connection reorderConnection, numParticlesChangedConnection;
    public:
     User(std::shared_ptr<ParticleData> pd){
       reorderConnection = pd->getReorderSignal()-> connect([this](){this->handle_reorder();});
       numParticlesChangedConnection = pd->getNumParticlesChangedSignal()->connect([this](int Nnew){this->handle_numChanged(Nnew);});
     }
     ~User(){
       reorderConnection.disconnect();
       numParticlesChangedConnection.disconnect();
     }
     void handle_reorder(){
       std::cout<<"A reorder occured!!"<std::endl;
     }  
     void handle_numChanged(int Nnew){
       std::cout<<"Particle number changed, now it is: "<<Nnew<<std::endl;
     }
  };

Note that it is possible that a module does not need to track the specific order of the particles or do anything special when the number of them changes. See for example NbodyForces or PairForces. Actually, most of the time you will get away without needing to connect to the signals.  

List of available signals
%%%%%%%%%%%%%%%%%%%%%%%%%%%%


* :code:`numParticlesChangedSignal() -> int` : Triggered when the total number of particles changes
      
* :code:`reorderSignal() -> void` : Triggered when the global sorting of particles changes
      
* :code:`[PROPERTY]WrittenSignal() -> void`: Triggered when PROPERTY has been requested with the write or readwrite flag. Notice that the signal is emitted at requesting of the property, so the requester has writing rights. These are auto generated for all properties (pos, vel, mass...) . One should use this callback merely for setting a flag for later work.
      




